# 批量拉取数据多线程优化 - 需求文档

## 一、需求背景

### 1.1 现状问题

当前股票K线数据批量拉取功能存在以下问题：

1. **效率低下**：采用单线程顺序执行，无法充分利用多个可用 Token 的并发能力
2. **缺少失败追溯**：同步失败时仅记录日志，无法查询和统计失败数据
3. **无补拉机制**：失败的数据无法自动或手动重试，需要重新执行整个批量同步

### 1.2 业务影响

- 批量同步 1000+ 只股票耗时过长（预估 10-20 分钟）
- Token 资源利用率低（有 10 个 Token 但只用 1 个）
- 失败数据需要人工排查日志，运维成本高

### 1.3 优化目标

1. **提升效率**：根据可用 Token 数量动态开启多线程，预期效率提升 2-3 倍
2. **失败可追溯**：记录失败的股票代码、日期范围、失败原因
3. **支持补拉**：提供补拉接口，专门处理失败记录

---

## 二、功能需求

### 2.1 多线程批量拉取

#### 需求描述
根据可用 Token 数量动态调整并发线程数，充分利用 Token 资源。

#### 业务规则
- **线程数计算公式**：`线程数 = 可用Token数 / 6`（向下取整）
- **最小线程数**：1（即使 Token 不足 6 个也要执行）
- **最大线程数**：10（避免过度并发）
- **Token 分配策略**：
  - 每个线程至少分配 6 个 Token
  - 如果有多余的 Token（可用Token数 % 6 的余数），均匀分配给所有线程
  - 线程内轮询使用 Token

#### Token 分配示例

| 可用 Token 数 | 计算线程数 | 实际线程数 | 每线程基础Token | 多余Token | 分配结果 |
|--------------|-----------|-----------|---------------|---------|---------|
| 5            | 5/6=0     | 1（最小值）| 5             | 0       | [5] |
| 12           | 12/6=2    | 2         | 6             | 0       | [6, 6] |
| 14           | 14/6=2    | 2         | 6             | 2       | [7, 7] |
| 20           | 20/6=3    | 3         | 6             | 2       | [7, 7, 6] |
| 30           | 30/6=5    | 5         | 6             | 0       | [6, 6, 6, 6, 6] |
| 35           | 35/6=5    | 5         | 6             | 5       | [7, 7, 7, 7, 7] |
| 100          | 100/6=16  | 10（最大值）| 10            | 0       | [10, 10, 10, 10, 10, 10, 10, 10, 10, 10] |

**分配算法说明**：
```
1. 计算线程数：threadCount = min(max(tokenCount / 6, 1), 10)
2. 计算每线程基础Token数：baseTokens = tokenCount / threadCount
3. 计算多余Token数：extraTokens = tokenCount % threadCount
4. 分配规则：
   - 前 extraTokens 个线程分配 (baseTokens + 1) 个 Token
   - 其余线程分配 baseTokens 个 Token
```

#### 技术要求
- 使用 `ThreadPoolExecutor` 创建线程池
- Token 预分配，避免线程间竞争
- 支持任务结果汇总（成功数、失败数）

---

### 2.2 失败记录机制

#### 需求描述
记录同步失败的股票信息，便于追溯和补拉。

#### 记录时机
在以下情况记录失败：
1. Token 不可用（线程的 Token 队列为空）
2. API 调用失败（超时、认证失败、限流）
3. 数据解析失败
4. 数据保存失败

#### 记录内容
| 字段 | 说明 | 示例 |
|------|------|------|
| 股票代码 | 失败的 |
| 开始日期 | 拉取的开始日期 | 2026-01-01 |
| 结束日期 | 拉取的结束日期 | 2026-01-31 |
| 失败原因 | 错误信息 | Token不可用 |
| 重试次数 | 已重试次数 | 0 |
| 状态 | 0-待重试，1-成功，2-放弃 | 0 |

#### 业务规则
- 同一股票同一日期范围的失败记录不重复插入（可更新重试次数）
- 失败记录保留 30 天（可配置）

---

### 2.3 补拉功能

#### 需求描述
提供补拉接口，专门处理失败记录，支持手动触发和自动重试。

#### 2.3.1 手动补拉

**触发方式**：前端页面点击"补拉失败数据"按钮

**查询条件**：
- 状态为"待重试"（status=0）
- 重试次数 < 最大重试次数（默认 3 次）
- 可选：按股票代码筛选

**执行逻辑**：
1. 查询符合条件的失败记录
2. 按股票代码去重（同一股票可能有多条记录）
3. 使用多线程执行补拉（复用批量同步逻辑）
4. 更新失败记录状态：
   - 成功：status=1
   - 失败：retry_count++，如果达到最大次数则 status=2

#### 2.3.2 自动重试（可选）

**触发方式**：定时任务（每天凌晨 2 点）

**执行逻辑**：
- 查询昨天的失败记录
- 自动执行补拉
- 发送通知（如果有失败）

---

## 三、非功能需求

### 3.1 性能要求

- 多线程同步 1000 只股票耗时 < 10 分钟（相比单线程提升 50%+）
- 单个线程处理 100 只股票耗时 < 2 分钟
- 失败记录查询响应时间 < 1 秒

### 3.2 可靠性要求

- Token 失效时不影响其他线程继续执行
- 线程异常不影响整体任务完成
- 失败记录 100% 准确记录

### 3.3 可维护性要求

- 线程数、重试次数等参数可配置
- 提供详细的日志记录（线程启动、任务分配、执行结果）
- 失败原因分类清晰（Token、API、解析、保存）

---

## 四、约束条件

### 4.1 技术约束

- iTick API 批量接口单次最多查询 100 只股票
- iTick API 可能有全局限流（具体限制未知）
- 数据库连接池大小需 >= 线程数

### 4.2 业务约束

- Token 每日限额机制保持不变
- Token 失败 3 次自动作废机制保持不变
- 不修改现有的单个同步接口
- **每个线程持有的 Token 数量不能少于 6 个**（保证线程有足够的 Token 轮询使用）

---

## 五、验收标准

### 5.1 功能验收

- [ ] 可根据 Token 数量动态创建线程池
- [ ] 每个线程至少持有 6 个 Token，多余 Token 均匀分配
- [ ] 多线程并发拉取数据，无数据丢失或重复
- [ ] 失败记录准确记录到数据库
- [ ] 补拉接口可正确处理失败记录
- [ ] 补拉成功后失败记录状态正确更新

### 5.2 性能验收

- [ ] 12 个 Token 同步 300 只股票耗时 < 5 分钟
- [ ] 失败记录查询响应时间 < 1 秒

### 5.3 稳定性验收

- [ ] Token 在执行过程中失效，任务继续执行
- [ ] 单个线程异常不影响其他线程
- [ ] 连续执行 10 次批量同步无异常

---

## 六、风险评估

| 风险 | 影响 | 概率 | 应对措施 |
|------|------|------|---------|
| API 限流 | 多线程可能触发限流 | 中 | 监控失败率，必要时降低线程数 |
| 连接池耗尽 | 数据库连接不足导致异常 | 低 | 确保连接池大小 >= 线程数 |
| 内存溢出 | 大量股票数据加载到内存 | 低 | 分批处理，及时释放内存 |
| Token 分配不均 | 某些线程 Token 耗尽而其他线程空闲 | 低 | 通过均匀分配多余 Token 缓解 |

---

## 七、后续优化方向

1. **动态 Token 借用**：线程间共享 Token 池，提高利用率
2. **进度监控**：实时显示同步进度（已完成/总数）
3. **失败分析**：统计失败原因分布，优化策略
4. **优先级队列**：失败次数少的股票优先补拉
